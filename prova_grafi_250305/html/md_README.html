<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: Lab prova_grafi_250305 - Bipartite Graph Product Rating System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Lab prova_grafi_250305 - Bipartite Graph Product Rating System </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md1"></a>
Overview</h1>
<p>This lab implements a <b>bipartite graph system</b> for managing and analyzing user ratings of products online. The system models users and products as nodes in a graph, with weighted edges representing ratings (1-5 stars) from users to products. This implementation demonstrates practical applications of graph data structures in recommendation systems and data mining.</p>
<h1><a class="anchor" id="autotoc_md2"></a>
Data Structures</h1>
<h2><a class="anchor" id="autotoc_md3"></a>
Node Information Structure (&lt;tt&gt;tipo_inf&lt;/tt&gt;)</h2>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">    <span class="keywordtype">char</span> descrizione[20];  <span class="comment">// Node description (user account or product name)</span></div>
<div class="line">    <span class="keywordtype">char</span> tipo;            <span class="comment">// Node type: &#39;U&#39; for User, &#39;P&#39; for Product</span></div>
<div class="line">} <a class="code" href="structtipo__inf.html">tipo_inf</a>;</div>
<div class="ttc" id="astructtipo__inf_html"><div class="ttname"><a href="structtipo__inf.html">tipo_inf</a></div><div class="ttdef"><b>Definition:</b> tipo.h:7</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md4"></a>
Graph Structure</h2>
<ul>
<li><b>Bipartite Graph</b>: Nodes are either users ('U') or products ('P')</li>
<li><b>Directed Edges</b>: From users to products only</li>
<li><b>Weighted Edges</b>: Edge weights represent star ratings (1-5)</li>
<li><b>Adjacency List Representation</b>: Efficient storage for sparse graphs</li>
</ul>
<h2><a class="anchor" id="autotoc_md5"></a>
Graph Node Structure (&lt;tt&gt;adj_node&lt;/tt&gt;)</h2>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structadj__node.html">adj_node</a> {</div>
<div class="line">    <span class="keywordtype">int</span> node;              <span class="comment">// Target node index</span></div>
<div class="line">    <span class="keywordtype">float</span> weight;          <span class="comment">// Rating (1-5 stars)</span></div>
<div class="line">    <span class="keyword">struct </span><a class="code" href="structadj__node.html">adj_node</a>* next; <span class="comment">// Next node in adjacency list</span></div>
<div class="line">};</div>
<div class="ttc" id="astructadj__node_html"><div class="ttname"><a href="structadj__node.html">adj_node</a></div><div class="ttdef"><b>Definition:</b> grafo.h:5</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md6"></a>
Sample Data Analysis</h1>
<h2><a class="anchor" id="autotoc_md7"></a>
From &lt;tt&gt;nodi.txt&lt;/tt&gt; (7 nodes):</h2>
<ul>
<li><b>Users</b>: Paolo (1), Giovanna (3), Carla (4), Pino (5)</li>
<li><b>Products</b>: Ciabatta (2), Scatola (6), Gioco (7)</li>
</ul>
<h2><a class="anchor" id="autotoc_md8"></a>
From &lt;tt&gt;valutazioni.txt&lt;/tt&gt; (Rating Graph):</h2>
<ul>
<li><b>Paolo</b>: Ciabatta (5★), Gioco (2★) → Average: 3.5</li>
<li><b>Giovanna</b>: Gioco (3★), Scatola (4★) → Average: 3.5</li>
<li><b>Carla</b>: Scatola (5★) → Average: 5.0</li>
<li><b>Pino</b>: Gioco (3★) → Average: 3.0</li>
</ul>
<h2><a class="anchor" id="autotoc_md9"></a>
Product Ratings:</h2>
<ul>
<li><b>Ciabatta</b>: 5★ (Paolo) → Average: 5.0</li>
<li><b>Scatola</b>: 4★ (Giovanna), 5★ (Carla) → Average: 4.5</li>
<li><b>Gioco</b>: 2★ (Paolo), 3★ (Giovanna), 3★ (Pino) → Average: 2.67</li>
</ul>
<h1><a class="anchor" id="autotoc_md10"></a>
Implemented Functions</h1>
<h2><a class="anchor" id="autotoc_md11"></a>
Core Data Management</h2>
<ol type="1">
<li>**<code>tipo_inf* <a class="el" href="compito_8cc.html#a34e66f1d50c07f0a9bf48f93c6dc148c" title="Creates and loads node information from nodi.txt file.">creaNodi(int&amp; n)</a></code>**<ul>
<li>Loads node information from <code>nodi.txt</code></li>
<li>Creates dynamic array of user and product nodes</li>
<li><b>Input file format</b>: Number of nodes, then pairs of (description, type)</li>
<li><b>Returns</b>: Array of nodes and count via reference</li>
</ul>
</li>
<li>**<code>void <a class="el" href="compito_8cc.html#ac8b1998155811171afd53e277e5b9308" title="Print ratings for each user.">stampa(graph g, tipo_inf* nodes, int dim)</a></code>**<ul>
<li>Prints all user ratings in format: "User valuta Rating Product"</li>
<li>Traverses adjacency lists for all user nodes</li>
<li><b>Use case</b>: Overview of all ratings in the system</li>
</ul>
</li>
</ol>
<h2><a class="anchor" id="autotoc_md12"></a>
Analytics Functions</h2>
<ol type="1">
<li>**<code>float <a class="el" href="compito_8cc.html#a7a535c5080f4f27d2112375572146663" title="Calculate average rating given by a specific user.">media_utente(char* account, graph g, tipo_inf* nodes, int dim)</a></code>**<ul>
<li>Calculates average rating given by a specific user</li>
<li><b>Algorithm</b>: Sum all ratings by user / number of products rated</li>
<li><b>Example</b>: Paolo rated Ciabatta (5★) and Gioco (2★) → Average: 3.5</li>
</ul>
</li>
<li>**<code>float <a class="el" href="compito_8cc.html#aee873fb6c1ff4d51b860ea149122a2c4" title="Calculate average rating of a specific product.">media_prod(char* prod, graph g, tipo_inf* nodes, int dim)</a></code>**<ul>
<li>Calculates average rating received by a specific product</li>
<li><b>Algorithm</b>: Sum all ratings for product / number of users who rated it</li>
<li><b>Example</b>: Scatola rated by Giovanna (4★) and Carla (5★) → Average: 4.5</li>
</ul>
</li>
</ol>
<h2><a class="anchor" id="autotoc_md13"></a>
Recommendation System</h2>
<ol type="1">
<li>**<code>void <a class="el" href="compito_8cc.html#a313858710a6084bffae10614df76c585" title="Suggest products to a user based on similar ratings.">suggerisci(char* account, char* prod, graph g, tipo_inf* nodes, int dim)</a></code>**<ul>
<li>Recommends products based on collaborative filtering</li>
<li><b>Algorithm</b>:<ul>
<li>Find users who rated the same product with the same rating</li>
<li>Suggest products these users rated with ≥3 stars</li>
<li>Exclude products already rated by the target user</li>
</ul>
</li>
<li><b>Example</b>: Pino and Giovanna both rated Gioco with 3★, so suggest Scatola (4★) to Pino</li>
</ul>
</li>
</ol>
<h1><a class="anchor" id="autotoc_md14"></a>
Key Algorithms and Concepts</h1>
<h2><a class="anchor" id="autotoc_md15"></a>
Bipartite Graph Properties</h2>
<h3><a class="anchor" id="autotoc_md16"></a>
Graph Structure Validation</h3>
<div class="fragment"><div class="line"><span class="comment">// In a bipartite graph, edges only exist between different node types</span></div>
<div class="line"><span class="keywordtype">bool</span> is_valid_bipartite(<a class="code" href="structgraph.html">graph</a> g, <a class="code" href="structtipo__inf.html">tipo_inf</a>* nodes, <span class="keywordtype">int</span> dim) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; dim; i++) {</div>
<div class="line">        <span class="keywordflow">if</span> (nodes[i].tipo == <span class="charliteral">&#39;U&#39;</span>) {  <span class="comment">// User nodes</span></div>
<div class="line">            <a class="code" href="structadj__node.html">adj_list</a> current = get_adjlist(g, i + 1);</div>
<div class="line">            <span class="keywordflow">while</span> (current != NULL) {</div>
<div class="line">                <span class="keywordtype">int</span> target = get_adjnode(current) - 1;</div>
<div class="line">                <span class="keywordflow">if</span> (nodes[target].tipo != <span class="charliteral">&#39;P&#39;</span>) <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// Must connect to product</span></div>
<div class="line">                current = get_nextadj(current);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="ttc" id="astructgraph_html"><div class="ttname"><a href="structgraph.html">graph</a></div><div class="ttdef"><b>Definition:</b> grafo.h:15</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md17"></a>
Rating Distribution Analysis</h3>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> analyze_rating_distribution(<a class="code" href="structgraph.html">graph</a> g, <a class="code" href="structtipo__inf.html">tipo_inf</a>* nodes, <span class="keywordtype">int</span> dim) {</div>
<div class="line">    <span class="keywordtype">int</span> rating_counts[6] = {0}; <span class="comment">// Index 0 unused, 1-5 for star ratings</span></div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; dim; i++) {</div>
<div class="line">        <span class="keywordflow">if</span> (nodes[i].tipo == <span class="charliteral">&#39;U&#39;</span>) {</div>
<div class="line">            <a class="code" href="structadj__node.html">adj_list</a> current = get_adjlist(g, i + 1);</div>
<div class="line">            <span class="keywordflow">while</span> (current != NULL) {</div>
<div class="line">                <span class="keywordtype">int</span> rating = (int)get_adjweight(current);</div>
<div class="line">                rating_counts[rating]++;</div>
<div class="line">                current = get_nextadj(current);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= 5; i++) {</div>
<div class="line">        cout &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; stars: &quot;</span> &lt;&lt; rating_counts[i] &lt;&lt; <span class="stringliteral">&quot; ratings&quot;</span> &lt;&lt; endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md18"></a>
Collaborative Filtering Implementation</h2>
<h3><a class="anchor" id="autotoc_md19"></a>
Find Similar Users</h3>
<div class="fragment"><div class="line">vector&lt;int&gt; find_similar_users(<span class="keywordtype">int</span> user_id, <a class="code" href="structgraph.html">graph</a> g, <a class="code" href="structtipo__inf.html">tipo_inf</a>* nodes, <span class="keywordtype">int</span> dim) {</div>
<div class="line">    vector&lt;int&gt; similar_users;</div>
<div class="line">    <a class="code" href="structadj__node.html">adj_list</a> user_ratings = get_adjlist(g, user_id);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// For each other user, calculate similarity</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; dim; i++) {</div>
<div class="line">        <span class="keywordflow">if</span> (nodes[i].tipo == <span class="charliteral">&#39;U&#39;</span> &amp;&amp; i + 1 != user_id) {</div>
<div class="line">            <span class="keywordtype">int</span> common_products = 0;</div>
<div class="line">            <span class="keywordtype">int</span> similar_ratings = 0;</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// Compare ratings with current user</span></div>
<div class="line">            <a class="code" href="structadj__node.html">adj_list</a> other_ratings = get_adjlist(g, i + 1);</div>
<div class="line">            <span class="comment">// Implementation of similarity calculation...</span></div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">if</span> (similarity_score &gt; threshold) {</div>
<div class="line">                similar_users.push_back(i + 1);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> similar_users;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md20"></a>
Product Recommendation Score</h3>
<div class="fragment"><div class="line"><span class="keywordtype">float</span> calculate_recommendation_score(<span class="keywordtype">int</span> user_id, <span class="keywordtype">int</span> product_id, </div>
<div class="line">                                   <a class="code" href="structgraph.html">graph</a> g, <a class="code" href="structtipo__inf.html">tipo_inf</a>* nodes, <span class="keywordtype">int</span> dim) {</div>
<div class="line">    <span class="keywordtype">float</span> score = 0;</div>
<div class="line">    <span class="keywordtype">int</span> count = 0;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Find users who rated this product</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; dim; i++) {</div>
<div class="line">        <span class="keywordflow">if</span> (nodes[i].tipo == <span class="charliteral">&#39;U&#39;</span> &amp;&amp; i + 1 != user_id) {</div>
<div class="line">            <a class="code" href="structadj__node.html">adj_list</a> ratings = get_adjlist(g, i + 1);</div>
<div class="line">            <span class="keywordflow">while</span> (ratings != NULL) {</div>
<div class="line">                <span class="keywordflow">if</span> (get_adjnode(ratings) == product_id) {</div>
<div class="line">                    <span class="comment">// Weight by user similarity</span></div>
<div class="line">                    <span class="keywordtype">float</span> similarity = calculate_user_similarity(user_id, i + 1);</div>
<div class="line">                    score += get_adjweight(ratings) * similarity;</div>
<div class="line">                    count++;</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                }</div>
<div class="line">                ratings = get_nextadj(ratings);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> (count &gt; 0) ? score / count : 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md21"></a>
Practical Applications</h1>
<h2><a class="anchor" id="autotoc_md22"></a>
E-commerce Recommendation Systems</h2>
<h3><a class="anchor" id="autotoc_md23"></a>
Amazon-style "Customers who bought this also bought"</h3>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> customers_also_bought(<span class="keywordtype">char</span>* product, <a class="code" href="structgraph.html">graph</a> g, <a class="code" href="structtipo__inf.html">tipo_inf</a>* nodes, <span class="keywordtype">int</span> dim) {</div>
<div class="line">    <span class="keywordtype">int</span> product_idx = find_product_index(product, nodes, dim);</div>
<div class="line">    <span class="keywordflow">if</span> (product_idx == -1) <span class="keywordflow">return</span>;</div>
<div class="line">    </div>
<div class="line">    map&lt;int, int&gt; co_purchased;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Find users who rated this product</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; dim; i++) {</div>
<div class="line">        <span class="keywordflow">if</span> (nodes[i].tipo == <span class="charliteral">&#39;U&#39;</span>) {</div>
<div class="line">            <span class="keywordtype">bool</span> rated_target = <span class="keyword">false</span>;</div>
<div class="line">            <a class="code" href="structadj__node.html">adj_list</a> ratings = get_adjlist(g, i + 1);</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// Check if user rated target product</span></div>
<div class="line">            <span class="keywordflow">while</span> (ratings != NULL) {</div>
<div class="line">                <span class="keywordflow">if</span> (get_adjnode(ratings) == product_idx) {</div>
<div class="line">                    rated_target = <span class="keyword">true</span>;</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                }</div>
<div class="line">                ratings = get_nextadj(ratings);</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// If yes, count all other products they rated</span></div>
<div class="line">            <span class="keywordflow">if</span> (rated_target) {</div>
<div class="line">                ratings = get_adjlist(g, i + 1);</div>
<div class="line">                <span class="keywordflow">while</span> (ratings != NULL) {</div>
<div class="line">                    <span class="keywordtype">int</span> other_product = get_adjnode(ratings);</div>
<div class="line">                    <span class="keywordflow">if</span> (other_product != product_idx) {</div>
<div class="line">                        co_purchased[other_product]++;</div>
<div class="line">                    }</div>
<div class="line">                    ratings = get_nextadj(ratings);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Print most co-purchased items</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; pair : co_purchased) {</div>
<div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;Also bought: &quot;</span> &lt;&lt; nodes[pair.first - 1].descrizione </div>
<div class="line">             &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; pair.second &lt;&lt; <span class="stringliteral">&quot; times)&quot;</span> &lt;&lt; endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md24"></a>
Social Network Analysis</h2>
<h3><a class="anchor" id="autotoc_md25"></a>
User Influence Scoring</h3>
<div class="fragment"><div class="line"><span class="keywordtype">float</span> calculate_user_influence(<span class="keywordtype">int</span> user_id, <a class="code" href="structgraph.html">graph</a> g, <a class="code" href="structtipo__inf.html">tipo_inf</a>* nodes, <span class="keywordtype">int</span> dim) {</div>
<div class="line">    <a class="code" href="structadj__node.html">adj_list</a> ratings = get_adjlist(g, user_id);</div>
<div class="line">    <span class="keywordtype">float</span> total_ratings = 0;</div>
<div class="line">    <span class="keywordtype">int</span> product_count = 0;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">while</span> (ratings != NULL) {</div>
<div class="line">        total_ratings += get_adjweight(ratings);</div>
<div class="line">        product_count++;</div>
<div class="line">        ratings = get_nextadj(ratings);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Influence = number of products rated * average rating</span></div>
<div class="line">    <span class="keywordflow">return</span> product_count * (total_ratings / product_count);</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md26"></a>
Product Popularity Analysis</h3>
<div class="fragment"><div class="line"><span class="keyword">struct </span>ProductStats {</div>
<div class="line">    <span class="keywordtype">string</span> name;</div>
<div class="line">    <span class="keywordtype">int</span> rating_count;</div>
<div class="line">    <span class="keywordtype">float</span> average_rating;</div>
<div class="line">    <span class="keywordtype">float</span> popularity_score;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">vector&lt;ProductStats&gt; analyze_product_popularity(<a class="code" href="structgraph.html">graph</a> g, <a class="code" href="structtipo__inf.html">tipo_inf</a>* nodes, <span class="keywordtype">int</span> dim) {</div>
<div class="line">    vector&lt;ProductStats&gt; stats;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; dim; i++) {</div>
<div class="line">        <span class="keywordflow">if</span> (nodes[i].tipo == <span class="charliteral">&#39;P&#39;</span>) {</div>
<div class="line">            ProductStats ps;</div>
<div class="line">            ps.name = nodes[i].descrizione;</div>
<div class="line">            ps.rating_count = 0;</div>
<div class="line">            <span class="keywordtype">float</span> total_rating = 0;</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// Count ratings for this product</span></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; dim; j++) {</div>
<div class="line">                <span class="keywordflow">if</span> (nodes[j].tipo == <span class="charliteral">&#39;U&#39;</span>) {</div>
<div class="line">                    <a class="code" href="structadj__node.html">adj_list</a> ratings = get_adjlist(g, j + 1);</div>
<div class="line">                    <span class="keywordflow">while</span> (ratings != NULL) {</div>
<div class="line">                        <span class="keywordflow">if</span> (get_adjnode(ratings) == i + 1) {</div>
<div class="line">                            total_rating += get_adjweight(ratings);</div>
<div class="line">                            ps.rating_count++;</div>
<div class="line">                            <span class="keywordflow">break</span>;</div>
<div class="line">                        }</div>
<div class="line">                        ratings = get_nextadj(ratings);</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            ps.average_rating = (ps.rating_count &gt; 0) ? total_rating / ps.rating_count : 0;</div>
<div class="line">            ps.popularity_score = ps.rating_count * ps.average_rating;</div>
<div class="line">            stats.push_back(ps);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> stats;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md27"></a>
Data Mining Applications</h2>
<h3><a class="anchor" id="autotoc_md28"></a>
Rating Pattern Analysis</h3>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> analyze_rating_patterns(<a class="code" href="structgraph.html">graph</a> g, <a class="code" href="structtipo__inf.html">tipo_inf</a>* nodes, <span class="keywordtype">int</span> dim) {</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;=== Rating Pattern Analysis ===&quot;</span> &lt;&lt; endl;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// User rating behavior</span></div>
<div class="line">    <span class="keywordtype">int</span> user_types[4] = {0}; <span class="comment">// harsh, average, generous, minimal</span></div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; dim; i++) {</div>
<div class="line">        <span class="keywordflow">if</span> (nodes[i].tipo == <span class="charliteral">&#39;U&#39;</span>) {</div>
<div class="line">            <span class="keywordtype">float</span> avg = <a class="code" href="compito_8cc.html#a7a535c5080f4f27d2112375572146663">media_utente</a>(nodes[i].descrizione, g, nodes, dim);</div>
<div class="line">            <span class="keywordflow">if</span> (avg &lt; 2.5) user_types[0]++; <span class="comment">// harsh</span></div>
<div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (avg &lt; 3.5) user_types[1]++; <span class="comment">// average</span></div>
<div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (avg &lt; 4.5) user_types[2]++; <span class="comment">// generous</span></div>
<div class="line">            <span class="keywordflow">else</span> user_types[3]++; <span class="comment">// very generous</span></div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Harsh critics: &quot;</span> &lt;&lt; user_types[0] &lt;&lt; endl;</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Average raters: &quot;</span> &lt;&lt; user_types[1] &lt;&lt; endl;</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Generous raters: &quot;</span> &lt;&lt; user_types[2] &lt;&lt; endl;</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Very generous: &quot;</span> &lt;&lt; user_types[3] &lt;&lt; endl;</div>
<div class="line">}</div>
<div class="ttc" id="acompito_8cc_html_a7a535c5080f4f27d2112375572146663"><div class="ttname"><a href="compito_8cc.html#a7a535c5080f4f27d2112375572146663">media_utente</a></div><div class="ttdeci">float media_utente(char *account, graph g, tipo_inf *nodes, int dim)</div><div class="ttdoc">Calculate average rating given by a specific user.</div><div class="ttdef"><b>Definition:</b> compito.cc:100</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md29"></a>
Build and Execution</h1>
<h2><a class="anchor" id="autotoc_md30"></a>
Compilation</h2>
<div class="fragment"><div class="line">make          # Compile the project</div>
<div class="line">make clean    # Clean build files</div>
<div class="line">make doc      # Generate documentation</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md31"></a>
Program Execution</h2>
<div class="fragment"><div class="line">./main</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md32"></a>
Expected Output</h2>
<div class="fragment"><div class="line">=== Stampa valutazioni per utente ===</div>
<div class="line">Paolo valuta 2 Gioco</div>
<div class="line">Paolo valuta 5 Ciabatta</div>
<div class="line">Giovanna valuta 4 Scatola</div>
<div class="line">Giovanna valuta 3 Gioco</div>
<div class="line">Carla valuta 5 Scatola</div>
<div class="line">Pino valuta 3 Gioco</div>
<div class="line"> </div>
<div class="line">Inserisci account per calcolare media utente: Paolo</div>
<div class="line">3.5</div>
<div class="line"> </div>
<div class="line">Inserisci account per suggerimenti: Pino</div>
<div class="line">Inserisci prodotto valutato: Gioco</div>
<div class="line">Suggerimento: Scatola</div>
<div class="line"> </div>
<div class="line">Inserisci prodotto per calcolare media: Scatola</div>
<div class="line">4.5</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md33"></a>
File Structure</h1>
<div class="fragment"><div class="line">prova_grafi_250305/</div>
<div class="line">├── compito.cc         # Main implementation</div>
<div class="line">├── grafo.cc          # Graph data structure implementation</div>
<div class="line">├── grafo.h           # Graph header file</div>
<div class="line">├── tipo.cc           # Node type implementation</div>
<div class="line">├── tipo.h            # Node type header</div>
<div class="line">├── Makefile          # Build configuration</div>
<div class="line">├── Doxyfile          # Documentation configuration</div>
<div class="line">├── nodi.txt          # Node data file</div>
<div class="line">├── valutazioni.txt   # Rating data file</div>
<div class="line">└── README.md         # This documentation</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md34"></a>
Advanced Concepts for Future Extensions</h1>
<h2><a class="anchor" id="autotoc_md35"></a>
Performance Optimizations</h2>
<h3><a class="anchor" id="autotoc_md36"></a>
Indexed Access</h3>
<div class="fragment"><div class="line"><span class="keyword">class </span>BipartiteGraph {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    unordered_map&lt;string, int&gt; user_index;</div>
<div class="line">    unordered_map&lt;string, int&gt; product_index;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> build_indices(<a class="code" href="structtipo__inf.html">tipo_inf</a>* nodes, <span class="keywordtype">int</span> dim) {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; dim; i++) {</div>
<div class="line">            <span class="keywordflow">if</span> (nodes[i].tipo == <span class="charliteral">&#39;U&#39;</span>) {</div>
<div class="line">                user_index[nodes[i].descrizione] = i + 1;</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                product_index[nodes[i].descrizione] = i + 1;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">int</span> find_user_fast(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name) {</div>
<div class="line">        <span class="keywordflow">return</span> user_index.count(name) ? user_index[name] : -1;</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md37"></a>
Caching System</h3>
<div class="fragment"><div class="line"><span class="keyword">class </span>RatingCache {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    unordered_map&lt;string, float&gt; user_averages;</div>
<div class="line">    unordered_map&lt;string, float&gt; product_averages;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">float</span> get_user_average(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; user, <span class="keywordtype">bool</span> use_cache = <span class="keyword">true</span>) {</div>
<div class="line">        <span class="keywordflow">if</span> (use_cache &amp;&amp; user_averages.count(user)) {</div>
<div class="line">            <span class="keywordflow">return</span> user_averages[user];</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordtype">float</span> avg = calculate_user_average(user);</div>
<div class="line">        user_averages[user] = avg;</div>
<div class="line">        <span class="keywordflow">return</span> avg;</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md38"></a>
Machine Learning Integration</h2>
<h3><a class="anchor" id="autotoc_md39"></a>
Rating Prediction</h3>
<div class="fragment"><div class="line"><span class="keywordtype">float</span> predict_rating(<span class="keywordtype">int</span> user_id, <span class="keywordtype">int</span> product_id, <a class="code" href="structgraph.html">graph</a> g, <a class="code" href="structtipo__inf.html">tipo_inf</a>* nodes, <span class="keywordtype">int</span> dim) {</div>
<div class="line">    <span class="comment">// Collaborative filtering prediction</span></div>
<div class="line">    vector&lt;int&gt; similar_users = find_similar_users(user_id, g, nodes, dim);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">float</span> weighted_sum = 0;</div>
<div class="line">    <span class="keywordtype">float</span> weight_sum = 0;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> similar_user : similar_users) {</div>
<div class="line">        <span class="keywordtype">float</span> similarity = calculate_similarity(user_id, similar_user);</div>
<div class="line">        <span class="keywordtype">float</span> rating = get_user_rating_for_product(similar_user, product_id);</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (rating &gt; 0) {</div>
<div class="line">            weighted_sum += similarity * rating;</div>
<div class="line">            weight_sum += similarity;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> (weight_sum &gt; 0) ? weighted_sum / weight_sum : 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md40"></a>
Scalability Considerations</h2>
<h3><a class="anchor" id="autotoc_md41"></a>
Memory Management</h3>
<ul>
<li><b>Large Datasets</b>: Consider using sparse matrix representations</li>
<li><b>Streaming Data</b>: Implement incremental graph updates</li>
<li><b>Distributed Systems</b>: Partition graph by user or product clusters</li>
</ul>
<h3><a class="anchor" id="autotoc_md42"></a>
Time Complexity Analysis</h3>
<ul>
<li><b>User Average</b>: O(degree(user)) = O(products_rated_by_user)</li>
<li><b>Product Average</b>: O(V) where V is number of users</li>
<li><b>Recommendations</b>: O(V²) in worst case for similarity calculations</li>
<li><b>Graph Traversal</b>: O(V + E) for complete analysis</li>
</ul>
<p>This lab demonstrates fundamental concepts in graph-based recommendation systems, providing a foundation for understanding more complex algorithms used in modern e-commerce and social media platforms.</p>
<h1><a class="anchor" id="autotoc_md43"></a>
Conceptual Connections to Other Labs</h1>
<h2><a class="anchor" id="autotoc_md44"></a>
Related Data Structures</h2>
<ul>
<li><b>Lab 190627</b>: Geographic POI graphs - similar graph traversal concepts</li>
<li><b>Lab 180719</b>: Social network graphs - user relationship modeling</li>
<li><b>Lab 240703</b>: BST hotel ratings - single-criterion rating systems</li>
</ul>
<h2><a class="anchor" id="autotoc_md45"></a>
Algorithmic Patterns</h2>
<ul>
<li><b>Graph Traversal</b>: Similar to social network analysis in Lab 180719</li>
<li><b>Rating Aggregation</b>: Related to BST range queries in Lab 240703</li>
<li><b>Recommendation Logic</b>: Collaborative filtering principles</li>
</ul>
<h2><a class="anchor" id="autotoc_md46"></a>
Real-World Applications Bridge</h2>
<ul>
<li><b>E-commerce</b>: Product recommendation engines</li>
<li><b>Social Media</b>: Content and friend recommendations</li>
<li><b>Entertainment</b>: Movie, music, and content suggestions</li>
<li><b>Business Intelligence</b>: Customer behavior analysis</li>
</ul>
<p>This bipartite graph implementation provides practical experience with recommendation systems that power modern digital platforms, making abstract graph theory concepts concrete and immediately applicable to real-world software development. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
